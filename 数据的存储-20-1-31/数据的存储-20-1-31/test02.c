#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//1E10：1.0*10^10
//浮点数存储的例子：
/*
n的值为：9
*pFloat的值为：0.000000
num的值为：1091567616
*pFloat的值为：9.000000

我们以整型的方式放进去，以整型的方式打印结果正常
我们以浮点型的方式放进去，以浮点型的方式打印结果正常
但是，我们以整型或者浮点型的方式放进去后，却以浮点型或者整型的方式打印出来，就跟预想的值不一样。

说明整型和浮点型在内存中，编译存在差异。
*/
/*
5.5
101.1
1.011*2^2

有的浮点数是不能精确保存的，比如：3.14
11.00110001010后面再加也总会缺一点到3.14。

E是无符号整型，但是有时候E算出来是有可能是负数的。
0.5--用二进制：0.1---(-1)^0 * 1.0*2^-1 
此时E为负数
*/

//测试一下5.5
/*
int main()
{
	float f = 5.5;
	//5.5--101.1--1.011*2^2--(-1)^0 * 1.011 * 2^2
	//S=0	M=1.011   E=2	
	//在内存中是怎么存放的：先放S，再放E，最后放M：其中E+127=129，129的二进制：1000 0001
	//0 10000001 0110000000000000000000
	//S	  E			M
	//翻译成16进制：
	//0100 0000 1011 0000 0000 0000 0000 0000
	//40 B0 00 00

	//我们进入调试界面，查看f的内存地址，就是 00 00 b0 40 小端存储

	return 0;
}
*/


int main()
{
	int n = 9;	
	//整型变量9存储的时候一定存储的是补码形式：
	//00000000 00000000 00000000 00001001
	//所以第一个printf()--打印整型9是确定无疑的。

	float *pFloat = (float *)&n;
	//*pFloat指向这个数，他会认为这个32位的比特位存放的是浮点数：第一位是S，后面8位是E，最后23位是M
	//0 00000000 00000000000000000001001
	//S	  E			M
	//S=0；E为全0；M前不加1，直接为小数点后面的数字。
	//(-1)^0 * 0.00000000000000000001001 * 2^-126
	//%f默认打印6位，本身就是一个很小的数
	printf("n的值为：%d\n", n);//9
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000

	*pFloat = 9.0;
	//1001.0--二进制表示9.0
	//(-1)^0 * 1.0010 * 2^3
	//S=0；E=3；M=1.0010
	//然后将此浮点数往内存存储：E=130
	//0 10000010 00100000000000000000000
	//S   E			M
	//0100 0001 0001 0000 0000 0000 0000 0000
	//然后我们以%d的形式进行打印，他就会拿整型的当时进行打印，他就会认为里面放的是补码，又因为符号位是0，所以放的是正数，正数的原反补码相同。
	//1091567616
	printf("num的值为：%d\n", n);//1091567616
	printf("*pFloat的值为：%f\n", *pFloat);//9.0

	return 0;
}
