#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//整型在内存中的存储
/*
原码、反码、补码
计算机中的有符号数有三种表示方法，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位三种表示方法各不相同。

原码：直接将十进制按照正负数的形式翻译成二进制就可以。
反码：将原码的符号位不变，其他位依次按位取反就可以得到了。
补码：反码+1就得到补码。

正数的原、反、补码都相同。
对于整形来说：数据存放内存中其实存放的是补码。
*/

/*
int main()
{
	int a = 20;
	//int类型的a--4个字节--32个bit-- 20的表示形式：
	//00000000 00000000 00000000 00010100 --原码
	//00000000 00000000 00000000 00010100 --反码
	//00000000 00000000 00000000 00010100 --补码
	//整数在内存中，存放的是补码：且是16进制的补码
	//0x00000014

	int b = -10;
	//int类型的b--4个字节--32个bit-- -10的表示形式：
	//10000000 00000000 00000000 00001010 --原码
	//11111111 11111111 11111111 11110101 --反码
	//11111111 11111111 11111111 11110110 --补码
	//整数在内存中，存放的是补码：且是16进制的补码
	//0xfffffff6


	//CPU只有加法器：
	// 1 - 1：1 + (-1)
	//原码计算：
	//00000000 00000000 00000000 00000001	加
	//10000000 00000000 00000000 00000001	等于
	//10000000 00000000 00000000 00000010	-2（所以用原码进行计算得到的是错误的结果）
	//补码计算：
	//00000000 00000000 00000000 00000001	(1的补码)加
	//11111111 11111111 11111111 11111111	(-1的补码)等于
	//10000000 00000000 00000000 000000000	因为整型只有32个比特位，所以丢掉一个最高位：
	//0000000 00000000 00000000 000000000	得到的补码，再转换成原码输出
	//1000000 00000000 00000000 000000000   得到：0



	//大端字节序存储：0x11 22 33 44
	//把一个数据的低位字节的内容，存放在高地址处，高位字节的内容，存放在低地址处。

	//小端字节序存储：0x44 33 22 11
	//把一个数据的低位字节的内容，存放在低地址处，高位字节的内容，存放在高地址处。
	int c = 0x11223344;
	//当前系统是按照小端字节序存储


	//设计代码判断是小端序存储还是大端字节序存储
	int d = 1;
	char * p = (char*)&d;
	if (*p == 1)
		printf("小端\n");
	else
		printf("大端\n");


	return 0;
}
*/


//以下代码输出什么？？？
//1、
/*
int main()
{
	//-1是一个整数--32bit--但我们的char类型只能存储8bit
	//-1的补码：
	//11111111 11111111 11111111 11111111	发生截断
	//11111111	这是a里面真是存的值。
	//打印%d，整型a，发生整型提升。高位按照符号位来看，对符号位进行提升，提升之后
	//11111111 11111111 11111111 11111111	再求其原码，进行打印
	//10000000 00000000 00000000 00000001	-1	
	//a和b是一样的道理
	char a = -1;
	signed char b = -1;
	//对于c来说，其截断后也是11111111，打印%d，整型a，发生整型提升，因为c是无符号型
	//00000000 000000000 00000000 11111111
	//在内存中来看，最高位为0，是一个正数，对于正数而言，其原码、反码、补码相同
	//二进制的8个1代表255，所以最终打印255
	unsigned char c = -1;
	printf("a=%d,b=%d,c=%d\n",a,b,c);//-1 -1 255


	return 0;
}
*/

//2、有符号的变量在进行整型提升的时候，是看最高位进行整型提升，无符号位就补0
/*
int main()
{
	//10000000 00000000 00000000 10000000	-原码
	//11111111 11111111 11111111 01111111	-反码
	//11111111 11111111 11111111 10000000	-补码
	//char类型的a在内存中存储：10000000
	//%u：无符号十进制整数：发生整型提升
	//11111111 11111111 11111111 10000000
	char a = -128;
	printf("a=%u\n", a);//a=4294967168


	return 0;
}
*/


//3、
/*
int main()
{
	//00000000 00000000 00000000 10000000	-原码	-反码	-补码
	//char类型的a在内存中存储：10000000
	//%u：无符号十进制整数：发生整型提升
	//11111111 11111111 11111111 10000000
	char a = 128;
	printf("%u\n",a);//a=4294967168

	return 0;
}
*/



//4、无符号数的原码反码补码是相同的
/*
int main()
{
	//i：
	//10000000 00000000 00000000 00010100	-原码
	//11111111 11111111 11111111 11101011	-反码
	//11111111 11111111 11111111 11101100	-补码
	int i = -20;
	//j：
	//00000000 00000000 00000000 00001010
	unsigned int j = 10;
	
	//i + j：
	//11111111 11111111 11111111 11101100	+
	//00000000 00000000 00000000 00001010	=
	//11111111 11111111 11111111 11110110
	//转换为反码：11111111 11111111 11111111 11110101
	//转换为补码：10000000 00000000 00000000 00001010
	printf("%d\n", i + j);//-10

	return 0;
}
*/


//5、无符号整型最小就为0，永远不可能为负数
#include <windows.h>
/*
int main()
{
	//00000000 00000000 00000000 00001001	9
	//00000000 00000000 00000000 00001000	8
	//00000000 00000000 00000000 00000111	7
	//00000000 00000000 00000000 00000110	6
	//00000000 00000000 00000000 00000101	5
	//00000000 00000000 00000000 00000100	4
	//00000000 00000000 00000000 00000011	3
	//00000000 00000000 00000000 00000010	2
	//00000000 00000000 00000000 00000001	1
	//00000000 00000000 00000000 00000000	0
	//11111111 11111111 11111111 11111111	...

	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n",i);
		Sleep(1000);
	}

	return 0;
}
*/


//6、
/*
int main()
{
	char a[1000];
	int i;
	for (i = 0; i<1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));//255
	return 0;
}
*/


//7、死循环
//0-255，始终没有256
/*
unsigned char i = 0;//全局变量
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
}
*/
