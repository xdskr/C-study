#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


/*
int main()
{
	int a = 10;
	int *p = &a;
	//p是一个指针变量，用来存放地址
	//一个变量可能占用多个字节，我们取地址，取得是起始位置的地址

	*p = 20;//解引用操作

	return 0;
}
*/


//指针和指针类型
//指针类型的第一个作用：决定了指针的访问权限，也就是能访问几个字节

/*
int main()
{
	int a = 0x11223344;
	//1、如果p是整型指针，解引用访问了4个字节
	int *p = &a;
	*p = 0;

	//2、如果p是字符指针，解引用访问了1个字节
	char *p = &a;
	*p = 0;

	//int * -- 4
	//char * -- 1
	//short * -- 2
	//float * -- 4
	//double * -- 8

	return 0;
}
*/

//指针类型的第二个作用：指针类型决定了指针+1，走多大距离
/*
int main()
{
	int arr[10] = { 0 };
	int * pa = arr;//数组名--首元素地址
	char * pc = arr;
	//printf("%p\n", arr);//0045F7D4

	printf("%p\n", pa);//0045F7D4
	printf("%p\n", pa + 1);//0045F7D8
	//跨过了4个字节，因为pa是个整型指针，整型指针+1，直接到下一个整型

	printf("--------------------------\n");

	printf("%p\n", pc);//0045F7D4
	printf("%p\n", pc + 1);//0045F7D5
	//只加了一个字节

	return 0;
}
*/


/*
int main()
{
	int arr[10] = { 0 };//相当于在内存中开辟了一条连续的空间
	int * p = arr;

	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = i;
	}

	for (i = 0; i < 10; i++)
	{
		printf("%d ",*(p + i));
	}

	//我希望把arr这10个整型的空间，看作40个字节的空间
	//给每个字节放一个字符进去 char * p = arr; i < 40;


	return 0;
}
*/

//野指针
//野指针不是说它的地址一直在变化，而是它的地址不属于该程序，在预想之外
//a一旦return，返回后，这块地址就不属于它了，这块空间就释放了
/*
int* test()
{
	int a = 10;
	return &a;
}

int main()
{
	//p得到地址之后，地址指向的空间已经释放了，所以这个时候的p就是野指针
	int *p = test();
	printf("hehe\n");
	printf("%d\n",*p);//随机值

	return 0;
}
*/

//野指针造成的原因一：指针未初始化
/*
int main()
{
	//这个p就是野指针
	int *p;//没有初始化 - 随机值
	*p = 20;

	return 0;
}
*/

//野指针造成的原因二：指针越界访问
/*
int main()
{
	int arr[10] = { 0 };
	int* p = arr;

	int i = 0;
	for (i = 0; i < 11; i++)
	{
		*(p + i) = i;
		//超出范围的那个，也会是随机值，导致野指针
	}


	return 0;
}
*/


//野指针造成的原因三：指针指向的空间释放
/*
如何避免野指针：
1、指针初始化
2、小心指针越界
3、指针指向空间释放及时置空
4、指针使用之前检查有效性
*/


/*
int main()
{
	//指针初始化的两种方法：
	//1、
	int a = 10;
	int *p1 = &a;
	//2、NULL - 空指针
	int *p2 = NULL;


	int arr[10] = { 0 };
	int *p3 = arr;
	//然后对p3进行各种操作
	//p3最后不指向arr了，及时置空
	p3 = NULL;


	//以下会是程序崩溃：写入位置0x00000000时发生访问冲突
	//NULL指向的空间不能访问的
	//int* ps = NULL;
	//*ps = 20;

	//改进：
	int* ps = NULL;
	if (ps != NULL)
	{
		*ps = 20;
	}


	return 0;
}
*/


//我们可以给指针任意赋一个16进制的数，以后再改，这在语法是允许的，但是不可行
//我们不知道我们写入的这个16进制所对应的地址，是不是允许我们访问的，容易造成非法访问
//实际上，我们在访问内存时，除了把某一块地址打印出来。我们也不会知道某一块内存的具体地址的。