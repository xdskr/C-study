#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stddef.h>


//1、结构体传参

/*
struct S
{
	int data[1000];
	int num;
};
struct S s = { { 1, 2, 3, 4 }, 1000 };

//结构体传参
void print1(struct S s)
{
	printf("%d\n", s.num);
}

//结构体地址传参
void print2(struct S* ps)
{
	printf("%d\n", ps->num);
}
int main()
{
	print1(s);//传结构体
	print2(&s); //传地址
	return 0;
}
*/
/*
上面的 print1 和 print2 函数哪个好些？
	答案是：首选print2函数。 原因：

	函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
	如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。

	结论： 结构体传参的时候，要传结构体的地址。
*/




//2、位段
/*
位段
	结构体讲完就得讲讲结构体实现 位段 的能力。
	什么是位段
		位段的声明和结构是类似的，有两个不同：
		1.位段的成员必须是 int、unsigned int 或signed int 。
		2.位段的成员名后边有一个冒号和一个数字。
*/

/*
//此时A就是一个位段，那么位段A的大小是什么？
//位段里面的位是二进制位
//位段可以在一定程度上节省空间
struct A
{
	//int _a;//4个字节 - 32个比特位
	//int _a : 35;//报错！int最大位32

	int _a : 2;//_a只需要2个比特位
	int _b : 5;//_b只需要5个比特位
	int _c : 10;//_c只需要10个比特位
	int _d : 30;//_d只需要30个比特位
};
int main()
{
	struct A sa;//
	//一次开辟一个整型 4个字节
	//4 -- 32
	//_a -2 剩30
	//_b -5 剩25
	//_c -10 剩15
	//4 -- 32
	//原来余15，又有了32，共计47
	//但之前剩余的15个比特位，到底用不用，C语言标准也没规定，_d不知道是用的剩余15+新的15，还是直接新的30
	//_d -30 剩17
	//这个过程中总共创建了8个字节

	printf("%d\n", sizeof(struct A));//8

	return 0;
}
*/


/*
位段的内存分配
1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
*/


//2.2 我们判断上述例子中，是用的旧的+新的，还是只用新的
//在当前的VS平台上：
//a：前一个空间剩余的比特位不够时，直接浪费，使用新开辟空间的比特位
//b：一个字节内部，是从低位到高位使用的。
//一个例子
//在16位的机器上， - int的大小是2个字节-16个比特位的
//在32位的机器上， - int的大小是4个字节-32个比特位的
/*
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	s.a = 10;
	s.b = 12;
	s.c = 3;
	s.d = 4;

	printf("%d\n", sizeof(s));//3

	return 0;
}
*/

/*
位段的跨平台问题
1. int 位段被当成有符号数还是无符号数是不确定的。
2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
	
总结：
	跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。
*/



//3、位段的应用：见笔记图