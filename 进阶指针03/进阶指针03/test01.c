#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>



//指针和数组笔试题解析

//一、
//1.数组名单独放在sizeof()内部，数组名表示整个数组，计算的是整个数组的大小，单位是字节
//2.&数组名，数组名表示整个数组，取出的是整个数组的地址
//除上面两种情况之外，所有的数组名都是数组首元素的地址
//地址的大小和它指向的空间大小无关，地址的大小就是4或8
//地址就是指针
/*
int main()
{
	//一维数组
	int a[] = { 1, 2, 3, 4 };

	printf("%d\n", sizeof(a));//16 - 数组名单独放在sizeof内部，计算的是整个数组的大小
	printf("%d\n", sizeof(a + 0));//4或8 - a不是单独放在sizeof内部，sizeof内部放的是a+0，也没有取地址，所以是两种情况之外的，所以a表示数组首元素的地址，地址的大小是4或8个字节，当前是32位计算机，所以是4，64-8
	printf("%d\n", sizeof(*a));//4 - *a放在sizeof内部，所以属于两种情况之外，a表示首元素1的地址，1的地址被解引用就是取出int类型的1，然后计算int类型1的大小。*a就是数组首元素
	printf("%d\n", sizeof(a + 1));//4或8 - 仍是两种情况之外，a+1指向的是数组第二个元素的起始位置，所以仍是4或8
	printf("%d\n", sizeof(a[1]));//4 - 数组[数字]代表数组中下标为数字的元素，即是2这个元素，所以是int类型2的大小，仍是4
	printf("%d\n", sizeof(&a));//4或8 - &a 取出的是整个数组的地址，他仍是地址，地址大小就是4或者8，数组的地址仍是地址，只不过+1的时候跳过的是整个数组
	printf("%d\n", sizeof(*&a));//16 - &a 取出的是整个数组的地址，然后对整个数组的地址进行解引用操作得到的是整个数组，整个数组的大小是16
	printf("%d\n", sizeof(&a + 1));//4或8 - &a 取出的是整个数组的地址，数组的地址+跳过整个数组，此时在数组末尾，不管在哪，始终指向的是一个地址，就算越界，也是指向地址，是地址就是4或8，这里不存在越界访问，只是拿了地址，没有访问地址的空间
	printf("%d\n", sizeof(&a[0]));//4或8 - a先跟[0]结合，代表数组首元素，然后对该元素进行取地址，所以仍是4或8【数组首元素地址】
	printf("%d\n", sizeof(&a[0] + 1));//4或8  - 先跟[0]结合，代表数组首元素，然后+1，代表数组第二个元素，然后对该元素进行取地址，所以仍是4或8【数组第二个元素的地址】

	return 0;
}
*/



/*
int main()
{
	//字符数组
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };

	//sizeof只关注空间的大小
	printf("%d\n", sizeof(arr));//6 - 数组名arr单独放在sizeof内部，计算的是整个数组大小，数组里面放了6个元素，每个元素都是char类型的，所以共占6个字节，跟"\0"无关
	printf("%d\n", sizeof(arr + 0));//4或8 - 数组名没有单独放在sizeof内部，页眉有取地址，所以是表示数组首元素地址，arr+0仍表示数组首元素地址，地址大小为4或8
	printf("%d\n", sizeof(*arr));//1 - arr表示数组首元素的地址，对其进行解引用操作，取到的是数组首元素，数组首元素是一个char类型的a字符，其大小为1
	printf("%d\n", sizeof(arr[1]));//1 - arr[1]表示数组中下标为1的元素，对其进行解引用操作，数组下标为1的元素是一个char类型的b字符，其大小为1
	printf("%d\n", sizeof(&arr));//4或8 - &a 取出的是整个数组的地址，他仍是地址，地址大小就是4或者8，数组的地址仍是地址，只不过+1的时候跳过的是整个数组
	printf("%d\n", sizeof(&arr + 1));//4或8 - &a 取出的是整个数组的地址，数组的地址+跳过整个数组，此时在数组末尾，不管在哪，始终指向的是一个地址，就算越界，也是指向地址，是地址就是4或8，这里不存在越界访问，只是拿了地址，没有访问地址的空间
	printf("%d\n", sizeof(&arr[0] + 1));//4或8  - 先跟[0]结合，代表数组首元素，然后+1，代表数组第二个元素，然后对该元素进行取地址，所以仍是4或8【数组第二个元素的地址】
	
	//strlen只关注"\0"
	printf("%d\n", strlen(arr));//随机值 - 我们只知道内存中中开辟了一块空间放一个数组，数组中有abcdef6个元素。strlen(arr)，他会从arr首地址元素开始往后数，知道碰到"\0"，"\0"前面有几个元素，结果就是几，这里往后找不到"\0"，就会显示随机值
	printf("%d\n", strlen(arr + 0));//随机值 - arr表示数组首元素的地址，然后arr+0仍表示数组首元素的地址，跟上一个一样，都是表示首元素地址，然后给strlen，计算长度，往后找"\0"，找不到，显示随机值
	//printf("%d\n", strlen(*arr));//报错 - arr表示首元素地址，然后对首元素地址进行解引用，得到的是数组的首元素a，a的ASCii值为97，他会把97当作一个地址，往后找"\0"，发生报错：读取97地址时发生访问冲突
	//printf("%d\n", strlen(arr[1]));//报错 - 理由同上，只不过访问的时b的ascii值
	printf("%d\n", strlen(&arr));//随机值 - &arr得到的是数组的地址，数组的地址在值上仍是数组首元素的地址，所以仍会从数组起始位置往后访问找"\0"，所以结果仍是随机值，且跟前面两个随机值结果一样
	printf("%d\n", strlen(&arr + 1));//随机值 - arr+1直接跳过arr数组，跑到后面的数组，然后对其进行取地址操作，然后在此地址为起点，往后找"\0"，仍得到随机值，但是这个随机值的结果比起前面来，数值-6，因为跳过了arr数组中的6个元素
	printf("%d\n", strlen(&arr[0] + 1));//随机值 - arr[0]+1得到的是数组中第二个元素，然后进行取地址操作，然后在此地址为起点，往后找"\0"，仍得到随机值，但是这个随机值的结果比起前面来，数值-1，因为跳过了arr数组中的a元素




	return 0;
}
*/



//sizeof(操作数) - 是一个操作符，计算操作数的所占空间的大小，可以计算类型、变量的大小，不关心内存里面放了什么，只关心大小
//strlen() - 求字符串长度的，只使用于字符串或者字符数组，它是一个库函数，不是操作符，求长度时，关注的是"\0"
/*
int main()
{

	//字符数组
	char arr[] = "abcdef";
	//我们拿字符串去初始化数组的时候，它里面就隐藏着"\0"。
	//这个数组里面放了7个字符：a b c d e f \0

	//sizeof只关注空间的大小
	printf("%d\n", sizeof(arr));//7 - arr单独放在sizeof内部，表示整个数组的大小，整个数组包含7个元素，每个元素都是char类型的
	printf("%d\n", sizeof(arr + 0));//4或8 - arr不是单独放在sizeof内部，所以arr这时候表示的是数组首元素地址，arr+0仍表示数组首元素的地址，地址的大小为4或8
	printf("%d\n", sizeof(*arr));//1 - arr不是单独放在sizeof内部，arr表示数组首元素地址，对其进行解引用操作，得到的是数组首元素a，a的大小为1
	printf("%d\n", sizeof(arr[1]));//1 - arr不是单独放在sizeof内部，arr表示数组首元素地址，arr[1]表示数组下标为1的元素b，b的大小为1
	printf("%d\n", sizeof(&arr));//4或8 - arr不是单独放在sizeof数组中，但是&arr取出的是整个数组的地址，是地址，其大小就是4或8
	printf("%d\n", sizeof(&arr + 1));//4或8 - &arr仍取出的是整个数组的地址，&arr+1跳过本数组，指向其他地址，是地址仍是4或8
	printf("%d\n", sizeof(&arr[0] + 1));//4或8 - arr[0]得到的是数组下标为0的元素a，然后+1，跳到b元素，对其进行取地址操作，得到b元素的地址，是地址就是4或8

	//strlen只关注"\0"
	printf("%d\n", strlen(arr));//6 - arr表示的是数组首元素的地址，然后从数组首元素开始往后找"\0"，找到"\0"之后，计算"\0"之前元素个数
	printf("%d\n", strlen(arr + 0));//6 - arr表示的是数组首元素的地址，arr+0仍表示数组首元素的地址，然后从数组首元素开始往后找"\0"，找到"\0"之后，计算"\0"之前元素个数
	//printf("%d\n", strlen(*arr));//报错 - arr表示数组首元素地址，然后对其进行解引用操作，得到元素a，然后计算a的长度，a的ASCii值为97，他会把97当作一个地址，往后找"\0"，发生报错：读取97地址时发生访问冲突
	//printf("%d\n", strlen(arr[1]));//报错 - 理由同上，只不过访问的时b的ascii值
	printf("%d\n", strlen(&arr));//6 - &arr得到的是整个数组的地址，整个数组的地址在数值上等于数组首元素的地址，所以仍会从数组起始位置往后访问找"\0"，找到"\0"之后，计算"\0"之前元素个数
	printf("%d\n", strlen(&arr + 1));//随机值 - arr+1直接跳过arr数组，跑到后面的数组，然后对其进行取地址操作，然后在此地址为起点，往后找"\0"，得到随机值
	printf("%d\n", strlen(&arr[0] + 1));//5 - arr[0]+1得到的是数组中第二个元素，然后进行取地址操作，然后在此地址为起点，往后找"\0"，这个值的结果比起前面来，数值-1，因为跳过了arr数组中的a元素

	return 0;
}
*/





/*
int main()
{

	//字符数组
	//此时p是一个指针，类型为：char *，此时p指向的是a的地址
	char *p = "abcdef";

	printf("%d\n", sizeof(p));//4或8 - sizeof里面放的指针p，此时指针p里面存放的是a的地址，是地址就是4或8。（p就是一个指针变量）
	printf("%d\n", sizeof(p + 1));//4或8 - p+1指向的是数组中第二个元素b的地址
	printf("%d\n", sizeof(*p));//1 - p指向的是数组首元素a的地址，然后对其进行解引用操作，得到元素a，然后计算a的大小（p是字符指针，*p访问一个字节）
	printf("%d\n", sizeof(p[0]));//1 - p[0] < == > *(p+0) < == > *p
	printf("%d\n", sizeof(&p));//4或8 - p是一个字符指针，存放的是字符a的地址，然后对p进行取地址操作，得到p的地址，是地址就是4或8
	printf("%d\n", sizeof(&p + 1));//4或8 - &p得到的是a的地址，&p+1得到的是p的下一段地址，不管指向那里，始终是个地址
	printf("%d\n", sizeof(&p[0] + 1));//4或8 - p[0]得到的是元素a，然后+1得到的是第二个元素，然后进行取地址操作，得到地址，计算地址的大小

	printf("%d\n", strlen(p));//6 - p里面放的是a的地址，从a开始往后找"\0"，找到"\0"之后，计算"\0"之前元素个数
	printf("%d\n", strlen(p + 1));//5 - p是a的地址，p+1代表b的地址，从b开始往后找"\0"，找到"\0"之后，计算"\0"之前元素个数
	//printf("%d\n", strlen(*p));//报错
	//printf("%d\n", strlen(p[0]));//报错
	printf("%d\n", strlen(&p));//随机值 - 字符指针p表示a的地址，然后对p进行取地址，然后以取到的p地址的首地址作为起点往后找"\0"
	printf("%d\n", strlen(&p + 1));//随机值 - 字符指针p表示a的地址，然后&p得到的是p的地址，然后+1跳过p的地址，然后以此为起点往后找"\0"，这个随机值的大小和上面无关，我们不知道取地址p的内存空间里放的内容，到哪里是"\0"
	printf("%d\n", strlen(&p[0] + 1));//5 - p[0]表示a，然后+1表示b，然后取地址，得到的是b的地址，然后以b为起始地址，往后找"\0"

	return 0;
}
*/






/*
int main()
{

	//二维数组
	int a[3][4] = { 0 };
	// 0 0 0 0
	// 0 0 0 0 
	// 0 0 0 0
	//对于二维数组来说，a[0]就是第0行的数组名


	printf("%d\n", sizeof(a));//48 - sizeof()里面放的是数组，此时计算的是整个数组的大小，整个数组有12个元素，每个元素都是int型，所以大小为48
	printf("%d\n", sizeof(a[0][0]));//4 - a[0][0]表示的是数组中第0行下标为0的元素，计算这个元素的大小，元素为int型，所以大小为4
	printf("%d\n", sizeof(a[0]));//16 - a[0]表示的是第0行元素，是第0行的数组名。即计算改行的大小，该行有4个元素，每个元素都是int型，所以大小为16
	printf("%d\n", sizeof(a[0] + 1));//4或8 - a[0]表示第0行的数组名，但是没有单独放在sizeof内部，所以它代表数组首元素地址，a[0]表示第0行元素，即指向第0行的首元素地址，然后+1表示第0行第二个元素的地址，是地址就是4或8
	printf("%d\n", sizeof(*(a[0] + 1)));//4 - 同上，(a[0]+1)表示的是第0行第1个元素的地址，然后对其进行解引用操作，第0行第1个元素，因为这个元素是int型，所以大小为4
	printf("%d\n", sizeof(a + 1));//4或8 - a此时不是单独放在sizeof内部，表示数组首元素的地址，即第0行的地址，即a表示的是一行的地址，+1表示第一行的地址，即a+1表示数组第一行的地址，地址大小即为4或8
	//a+1表示第一行的地址，其类型为：int(*)[4]

	//*(a+1) < == > a[1] < == > a[1]表示二维数组第一行的数组名，数组名放在sizeof内部，表示整个数组的大小，即整个第一行的大小
	printf("%d\n", sizeof(*(a + 1)));//16 - a+1表示第一行的地址，其类型为 int(*)[4]，对其进行解引用得到的是第一行，第一行的大小为16
	printf("%d\n", sizeof(&a[0] + 1));//4或8 - a[0]是数组第0行数组名，然后取地址，&数组名，取出的是第0行的数组名，然后+1，表示第一行的地址，地址的大小即为4或8
	printf("%d\n", sizeof(*(&a[0] + 1)));//16 - 对第一行进行取地址操作，得到的是第一行，第一行的大小为16

	//*(a+0) < == > a[0]
	printf("%d\n", sizeof(*a));//16 - 此时a表示的是数组首元素的地址，即第0行的地址，然后解引用，得到的是第一行，即计算第一行的大小，为16
	printf("%d\n", sizeof(a[3]));//16 - a[3]表示第四行的数组名，作为数组名出现在sizeof内部表示整个数组的大小，即第四行的大小，但整个数组只有三行
	//这里不会存在越界访问的问题，我们只是访问第四行，并没有取元素，所以不会存在越界访问的问题，并且sizeof内部的表达式是参与运算的
	//我们只是通过a[3]明确它的类型，明确了类型就可计算大小，

	return 0;
}
*/


