#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


// ~ 按位取反
/*
int main()
{

	// ~ 对操作数的二进制进行按位取反
	int a = 0;
	//a：00000000 00000000 00000000 00000000 -原码(反码)(补码)
	//取反：11111111 11111111 11111111 11111111 -- 这是在内存中存储的，以补码形式
	//打印在屏幕上是原码：-1取反
	//11111111 11111111 11111111 11111110 -- -1之后的值
	//10000000 00000000 00000000 00000001 -- 除符号位，其余位取反，值为-1
	printf("%d\n",~a);




	return 0;
}

*/


// 操作符用处
/*
int main()
{
	int a = 13;
	//00000000 00000000 00000000 00001101
	//我们想要把以上的二进制位变成：00000000 00000000 00000000 00001111

	//00000000 00000000 00000000 00001101
	//按位或
	//00000000 00000000 00000000 00000010
	//结果为：
	//00000000 00000000 00000000 00001111
	a | (1 << 1);


	//我们想把下面这个数
	int b = 15;
	//00000000 00000000 00000000 00001111
	//变成：
	//00000000 00000000 00000000 00001101
	//只需将原数按位与下面的数：
	//11111111 111111111 11111111 11111101
	b & (~(1 << 1));
	


	return 0;
}
*/

//之前：scanf进行多组输入的时候，只要不等于FOF，就一直取
//EOF的值为-1，按位取反即为0（~-1 = 0），即为假，停止
/*
int main()
{
	int a = 0;
	while (~scanf("%d",&a))
	{

	}

	return 0;
}
*/


// ++ -- 操作符
//分为前置和后置之分
/*
int main()
{
	int a = 10;
	int b = ++a;//前置++：先++，后使用
	int c = a++;//后置++：先使用，后++
	printf("%d %d %d\n",a,b,c);

	return 0;
}
*/


// 强制类型转换
/*
int main()
{
	int a = (int)3.14;

	double b = 3.14;//最好在写代码的时候，就控制好类型，避免发生

	return 0;
}
*/


//sizeof()和数组的练习
/*
void test1(int arr[]){
	printf("%d\n", sizeof(arr));//4
	//数组传参，传过来的是首元素的地址
}

void test2(char ch[]){
	printf("%d\n", sizeof(ch));//4
	//指针的大小都是一样的，跟32位和64位有关
}

int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr));//40
	printf("%d\n", sizeof(ch));//10
	//一个char是一个字节

	test1(arr);
	test2(ch);

	return 0;
}
*/

 
//关系操作符
/*
int main()
{
	// > >=
	// < <=
	// != 用于测试不相等
	// == 用于测试相等

	//有些东西是不能用==比较的，字符串不可以用==比较，==比较的是字符串的地址
	//字符串用：strcmp比较

	return 0;
}
*/


//逻辑操作符
// &  按位与
// && 逻辑与
// |  按位或
// || 逻辑或
//逻辑与和逻辑或真关心真假，不关心二进制位
/*
int main()
{
	int a = 3;
	int b = 4;
	int d = 0;
	int c = a&&b;// && 逻辑与
	int e = a&&d;

	int f = a||b;// || 逻辑或
	int g = a||d;
	printf("%d\n",f);
	printf("%d\n", g);

	return 0;
}
*/


//360笔试题
//对于逻辑与&&操作符，左边如果为假，右边不再计算
//对于逻辑或||操作符，左边如果为真，右边不再计算
/*
int main()
{
	int i = 0, a = 0, b = 2, c = 3,d = 4;
	//i = a++ && ++b && d++;
	//a++，先使用，后++，所以0&&任何数都为0，后面就不用算了，短路与
	//所以bd没有参与运算，只有a变为1了

	i = a++ || ++b || d++;
	//a++，先使用，后++，所以0||++b为真，后面就不用算了，短路或，d没有参加运算


	printf(" a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);
	printf(" i = %d\n",i);

	return 0;
}
*/


//条件操作符（三目操作符）唯一的三目操作符，有3个操作数
/*
int main()
{
	//exp1 ? exp2 : exp3
	//当表达式1为真，表达式2计算，表达式3不算
	//当表达式1为假，表达式3计算，表达式2不算


	return 0;
}
*/


//逗号表达式
//exp1,exp2,exp3,...,expn
//逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果
/*
int main()
{
	int a = 1;
	int b = 2;
	int c = (a>b,a=b+10,a,b=a+1);//前面的值会对后面的值有影响
	printf("c = %d\n", c);//13

	if (a = b + 1, a = a / 2, d > 0){}


	while(){a = get_val(), count_val(a), a > 0}

	return 0;
}
*/


//下标引用、函数调用和结构成员
/*
void test(){}

//函数名前面的返回值类型，可以省略，但是省略掉后，默认返回的是整型
Add(int x,int y)
{
	return x + y;
}

//自己创造类型
struct Student
{
	//结构成员：name、age、sex
	char name[20];//名字
	int age;//年龄
	char sex[5];//性别
};

int main()
{
	//下标引用
	int arr[10] = { 0 };
	arr[4] = 4;//[]就是下标引用操作符 - []的两个操作数：arr和4

	//函数调用
	test();//()就是函数调用操作符 - ()的两个操作数：test
	//不带括号就不是在调用函数，调用函数必须要用括号()
	Add(2, 3);//操作数为：Add、2、3

	//函数调用操作符的操作数至少有一个


	//结构成员访问操作符--建立在结构体(联合体)上的
	struct Student s = {"张三",20,"男"};
	printf("%s\n", s.name);
	printf("%d\n", s.age);
	printf("%s\n", s.sex);
	// . 操作符，结构体变量.结构成员

	//通过指针
	struct Student* ps = &s;//拿到了ps
	printf("%s\n", (*ps).name);
	printf("%d\n", (*ps).age);
	printf("%s\n", (*ps).sex);//繁琐


	//结构体指针->结构成员
	printf("%s\n", ps -> name);//简化
	printf("%d\n", ps -> age);
	printf("%s\n", ps -> sex);




	return 0;
}
*/




//表达式求值：
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。
//同样，有些表达式的操作数在求值的过程中可能需要转换为其它类型。
/*
int main()
{
	int a = 3 + (2 - 4) * 6;//优先级决定优先顺序
	int b = 3 + 5 + 8;//相邻2个操作符的优先级相同，这时结合性说了算
	//+ 从左向右结合

	return 0;
}
*/

//隐士类型转换
/*
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整型提升（大小小于int的char、short才整型提升）
*/

/*
整型提升的意义：
表达式的整形运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器长度。
因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算(虽然机器指令中可能有这种字节相加指令)。所以，表达式中各种长度可能小于int长度的
整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。
*/

/*
int main()
{
	//char -- signed char
	char a = 3;
	//00000000 00000000 00000000 00000011--3是一个整型，但是a是一个char，只有1个字节，
	//发生截断
	//00000011 - a
	char b = 127;
	//00000000 00000000 00000000 01111111--127是一个整型，但是b是一个char，只有1个字节，
	//发生截断
	//01111111 - b
	char c = a + b;
	//a和b的大小不够一个整型大小，所以要发生整型提升
	//整型提升是按照变量原符号位来提升的（如果是负数，全部补1）
	//00000000 00000000 00000000 00000011
	//00000000 00000000 00000000 01111111
	//相加：
	//00000000 00000000 00000000 10000010

	//但是a+b要放到char类型的c中，发生截断
	//10000010 -- c

	printf("%d\n", c);//-126
	//%d - 按照有符号整型打印的
	//要发生整型提升：
	//11111111 11111111 11111111 10000010 -补码（这是有符号提升之后的，在内存中存储的，以补码形式存在）
	//将以上补码变为原码，因为打印的都是原码
	//11111111 11111111 11111111 10000001 - 反码
	//10000000 00000000 00000000 01111110 - 原码 -126


	return 0;
}
*/


//整型提升实例1：
/*
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a\n");
	if (b == 0xb600)
		printf("b\n");
	if (c == 0xb6000000)
		printf("c\n");
	//结果打印c

	//c不会发生整型提升

	return 0;
}
*/

//整型提升实例2：
/*
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c));//1
	printf("%u\n", sizeof(+c));//4
	printf("%u\n", sizeof(-c));//4
	//后两个参与运算，发生了整型提升。
	return 0;
}
*/

