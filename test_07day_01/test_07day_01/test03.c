#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


//数组

//1、数组的创建
/*
int main()
{
	int arr[10];
	char ch[5 + 5];

	//int n = 10;
	//int arr2[n];//报错
	//变长数组，-C99标准中引入的，vs2013对C99的支持不好。

	return 0;
}
*/

//2、数组的初始化
/*
int main()
{
	int arr1[10];//如果不初始化，里面放的都是一些随机值。
	int arr2[10] = {1};//不完全初始化，只初始化了第一个元素为1，其他默认为0
	int arr3[5] = { 1, 2, 3, 4, 5 };//完全初始化
	int arr4[10] = { 0 };//虽然是不完全初始化，但默认元素也是0，还是达到了全部为0的目的。
	int arr5[] = { 0 };//不行，这样初始化，只有一个元素，没有给定数组大小，会根据后面初始化内容，给定数组大小。

	char ch1[10] = {0};
	char ch2[10] = { 'a', 'b', 'c' };
	char ch3[] = "abcd";//用双引号来初始化，放了5个元素：a b c d \0


	char ch4[10] = { 'a', 'b', 'c' }; //放了3个元素：a b c
	char ch5[] = "abc";//用双引号来初始化，放了4个元素：a b c \0
	//这两种方式创建是有很大区别的，打印结果也有很大区别：
	//ch5：只打印abc
	//ch4：abc后面出现随机值
	//“abc”后面有\0，停止的标志，会停下来，而''字符创建，找不到结束的标志，所以会出现随机值

	//再求上面两种的长度：
	//ch5的长度就是：3
	//ch4的长度：随机值


	char ch6[10] = { 'a', 'b', 'c' ,'\0'}; 
	char ch7[10] = { 'a', 'b', 'c', 0 };
	//这样的效果就和ch5一样了


	
	return 0;
}
*/


//3、数组的访问
/*
int main()
{
	char ch1[] = {'b','i','t'};
	//数组下标从0开始
	printf("%c\n",1);

	int i = 0;
	int sz = sizeof(ch1) / sizeof(ch1[0]);
	for ( i = 0; i < sz; i++)
	{
		printf("%c ", ch1[i]);
	}

	return 0;
}
*/


//4、一维数组在内存中的存储
/*
int main()
{
	int i = 0;

	int arr[10] = { 0 };
	int sz = sizeof(arr) / sizeof(arr[0]);

	int *p = arr;//数组名-数组首元素的地址
	//我们把arr赋值给p，所以p指向arr数组的第一个元素，
	p + 1;//是数组arr中下标为1的元素的地址
	p + 2;//是数组arr中下标为2的元素的地址
	//增加了一个访问数组的方法！！！！！！！！！！！！！！
	for (i = 0; i < sz; i++)
	{
		printf("%d ",*(p+i));
		//p+i拿到地址，然后解引用操作，获取值
		//使用指针p访问数组
	}


	for (i = 0; i < sz; i++)
	{
		printf("&arr[%d] = %p\n", i, &arr[i]);//打印地址
		//每个地址之间是等差的，相差4。
		//一个整型元素4个字节，所以数组在内存中地址是连续增长的，增长的就是一个数字的大小
		//所以：：：：：：
		//数组在内存中是连续存放的！！！！
		//随着数组下标的增大，地址是由低到高变化的。
	}

	return 0;
}
*/

